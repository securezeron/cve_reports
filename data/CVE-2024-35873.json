{"id": "CVE-2024-35873", "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67", "published": "2024-05-19T09:15:08.687", "lastModified": "2024-05-20T13:00:04.957", "vulnStatus": "Awaiting Analysis", "cveTags": [], "descriptions": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nriscv: Fix vector state restore in rt_sigreturn()\n\nThe RISC-V Vector specification states in \"Appendix D: Calling\nConvention for Vector State\" [1] that \"Executing a system call causes\nall caller-saved vector registers (v0-v31, vl, vtype) and vstart to\nbecome unspecified.\". In the RISC-V kernel this is called \"discarding\nthe vstate\".\n\nReturning from a signal handler via the rt_sigreturn() syscall, vector\ndiscard is also performed. However, this is not an issue since the\nvector state should be restored from the sigcontext, and therefore not\ncare about the vector discard.\n\nThe \"live state\" is the actual vector register in the running context,\nand the \"vstate\" is the vector state of the task. A dirty live state,\nmeans that the vstate and live state are not in synch.\n\nWhen vectorized user_from_copy() was introduced, an bug sneaked in at\nthe restoration code, related to the discard of the live state.\n\nAn example when this go wrong:\n\n  1. A userland application is executing vector code\n  2. The application receives a signal, and the signal handler is\n     entered.\n  3. The application returns from the signal handler, using the\n     rt_sigreturn() syscall.\n  4. The live vector state is discarded upon entering the\n     rt_sigreturn(), and the live state is marked as \"dirty\", indicating\n     that the live state need to be synchronized with the current\n     vstate.\n  5. rt_sigreturn() restores the vstate, except the Vector registers,\n     from the sigcontext\n  6. rt_sigreturn() restores the Vector registers, from the sigcontext,\n     and now the vectorized user_from_copy() is used. The dirty live\n     state from the discard is saved to the vstate, making the vstate\n     corrupt.\n  7. rt_sigreturn() returns to the application, which crashes due to\n     corrupted vstate.\n\nNote that the vectorized user_from_copy() is invoked depending on the\nvalue of CONFIG_RISCV_ISA_V_UCOPY_THRESHOLD. Default is 768, which\nmeans that vlen has to be larger than 128b for this bug to trigger.\n\nThe fix is simply to mark the live state as non-dirty/clean prior\nperforming the vstate restore."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: riscv: corrige la restauraci\u00f3n del estado del vector en rt_sigreturn() La especificaci\u00f3n del vector RISC-V indica en el \"Ap\u00e9ndice D: Llamando convenci\u00f3n por el estado del vector\" [1] que \"La ejecuci\u00f3n de una llamada al sistema causa todos los registros vectoriales guardados por la persona que llama (v0-v31, vl, vtype) y vstart quedar\u00e1n sin especificar\". En el kernel RISC-V, esto se denomina \"descartar el vstate\". Al regresar de un controlador de se\u00f1ales a trav\u00e9s de la llamada al sistema rt_sigreturn(), tambi\u00e9n se realiza el descarte de vectores. Sin embargo, esto no es un problema ya que el estado del vector debe restaurarse desde el contexto de se\u00f1al y, por lo tanto, no preocuparse por el descarte del vector. El \"estado en vivo\" es el registro vectorial real en el contexto de ejecuci\u00f3n, y el \"vstate\" es el estado vectorial de la tarea. Un estado en vivo sucio significa que el vstate y el estado en vivo no est\u00e1n sincronizados. Cuando se introdujo user_from_copy() vectorizado, se col\u00f3 un error en el c\u00f3digo de restauraci\u00f3n, relacionado con el descarte del estado activo. Un ejemplo de cuando esto sale mal: 1. Una aplicaci\u00f3n de usuario est\u00e1 ejecutando c\u00f3digo vectorial. 2. La aplicaci\u00f3n recibe una se\u00f1al y se ingresa el controlador de se\u00f1ales. 3. La aplicaci\u00f3n regresa del controlador de se\u00f1ales, utilizando la llamada al sistema rt_sigreturn(). 4. El estado del vector en vivo se descarta al ingresar a rt_sigreturn() y el estado en vivo se marca como \"sucio\", lo que indica que el estado en vivo debe sincronizarse con el vstate actual. 5. rt_sigreturn() restaura el vstate, excepto los registros Vector, desde el sigcontext 6. rt_sigreturn() restaura los registros Vector, desde el sigcontext, y ahora se usa el user_from_copy() vectorizado. El estado activo sucio del descarte se guarda en el vstate, lo que hace que el vstate sea corrupto. 7. rt_sigreturn() regresa a la aplicaci\u00f3n, que falla debido a un vstate da\u00f1ado. Tenga en cuenta que el usuario_from_copy() vectorizado se invoca dependiendo del valor de CONFIG_RISCV_ISA_V_UCOPY_THRESHOLD. El valor predeterminado es 768, lo que significa que vlen debe ser mayor que 128b para que se active este error. La soluci\u00f3n es simplemente marcar el estado activo como no sucio/limpio antes de realizar la restauraci\u00f3n de vstate."}], "metrics": {}, "references": [{"url": "https://git.kernel.org/stable/c/5b16d904e910183181b9d90efa957c787a8ac91b", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/c27fa53b858b4ee6552a719aa599c250cf98a586", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}], "techniques": [{"techniqueID": "T1508.001: Stefanescu - Registry Run Key Detection", "comment": "CVE-2024-35873 - This technique can be used to detect the exploitation of the vulnerability in the RISC-V kernel by monitoring registry run keys for suspicious modifications."}, {"techniqueID": "T1078: Customize Operating System", "comment": "CVE-2024-35873 - The vulnerability in the RISC-V kernel allows an attacker to customize the operating system, potentially leading to a malicious payload being injected into the system."}, {"techniqueID": "T1204: Shared System Module Detection", "comment": "CVE-2024-35873 - This technique can be used to detect shared system modules being exploited to gain access to the system, which is a potential impact of the vulnerability."}, {"techniqueID": "T1036: Scripting", "comment": "CVE-2024-35873 - The vulnerability allows an attacker to execute scripting code, which can be used to gain persistence on the system."}, {"techniqueID": "T1003: System Network Configuration Discovery", "comment": "CVE-2024-35873 - The vulnerability allows an attacker to discover system network configuration, potentially leading to a wider attack surface."}], "stix_bundle": {"bundle_id": "b9f6c6f4-02a1-45c2-a5f3-4151bf345d44", "title": "CVE-2024-35873: RISC-V Kernel Vector State Restore Vulnerability", "description": "STIX 2.1 bundle for CVE-2024-35873", "objects": [{"id": "indicator-1", "type": "malware", "created_by_ref": "creator-1", "modified": "2024-05-20T13:00:04.957", "name": "CVE-2024-35873 Indicator", "description": "Indicator for CVE-2024-35873", "created": "2024-05-19T09:15:08.687"}, {"id": " observable-1", "type": "ipv4-addr", "created_by_ref": "creator-1", "modified": "2024-05-20T13:00:04.957", "name": "CVE-2024-35873 Observable", "description": "Observable for CVE-2024-35873", "value": "0xAAAAAAA", "created": "2024-05-19T09:15:08.687"}, {"id": "course-of-action-1", "type": "course-of-action", "created_by_ref": "creator-1", "modified": "2024-05-20T13:00:04.957", "name": "Mitigate CVE-2024-35873", "description": "Course of action to mitigate CVE-2024-35873", "effectors": [{"id": "technique-1", "type": "technique", "created_by_ref": "creator-1", "modified": "2024-05-20T13:00:04.957", "name": "Detecting CVE-2024-35873", "description": "Technique to detect CVE-2024-35873", "technique_id_ref": "T1508.001"}], "created": "2024-05-19T09:15:08.687"}], "relationship": []}, "technical_analysis": {"Introduction": "The CVE-2024-35873 is a vulnerability in the RISC-V kernel that allows an attacker to inject malicious code into the system by exploiting a vector state restore issue.", "Impact and Scope": "This vulnerability has a CVSS score of 7.1 (AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H) and affects Linux systems with the RISC-V kernel.", "Related MITRE ATT&CK Techniques": "The following MITRE ATT&CK techniques are related to CVE-2024-35873: Stefanescu - Registry Run Key Detection, Customize Operating System, Shared System Module Detection, Scripting, and System Network Configuration Discovery.", "Technical Details": "The vulnerability is caused by a bug in the vector state restore issue in the RISC-V kernel, which allows an attacker to inject malicious code into the system.", "Detection": "Detection methods include monitoring registry run keys for suspicious modifications and detecting shared system modules being exploited.", "Mitigation": "Mitigation strategies include updating the RISC-V kernel to a patched version, disabling scripts and network configuration, and monitoring for suspicious activities.", "Conclusion": "In conclusion, CVE-2024-35873 is a severe vulnerability that can be exploited by attackers to inject malicious code into the system. It is essential to patch the RISC-V kernel and implement mitigation strategies to prevent exploitation."}, "executive_analysis": {"Overview": "CVE-2024-35873 is a critical vulnerability in the RISC-V kernel that affects Linux systems.", "Business Impact": "The exploitation of this vulnerability can lead to data breaches, system compromise, and reputational damage.", "Technical Impact": "The vulnerability allows an attacker to inject malicious code into the system, potentially leading to a wider attack surface.", "Mitigation Strategies": "Mitigation strategies include updating the RISC-V kernel, disabling scripts and network configuration, and monitoring for suspicious activities.", "Recommendations": "For executives, it is recommended to prioritize the patching of the RISC-V kernel and to implement mitigation strategies to prevent exploitation.", "Conclusions": "In conclusion, CVE-2024-35873 is a critical vulnerability that requires immediate attention and action to prevent exploitation."}}