{"id": "CVE-2024-40910", "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67", "published": "2024-07-12T13:15:14.213", "lastModified": "2024-08-29T13:55:38.203", "vulnStatus": "Analyzed", "cveTags": [], "descriptions": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nax25: Fix refcount imbalance on inbound connections\n\nWhen releasing a socket in ax25_release(), we call netdev_put() to\ndecrease the refcount on the associated ax.25 device. However, the\nexecution path for accepting an incoming connection never calls\nnetdev_hold(). This imbalance leads to refcount errors, and ultimately\nto kernel crashes.\n\nA typical call trace for the above situation will start with one of the\nfollowing errors:\n\n    refcount_t: decrement hit 0; leaking memory.\n    refcount_t: underflow; use-after-free.\n\nAnd will then have a trace like:\n\n    Call Trace:\n    <TASK>\n    ? show_regs+0x64/0x70\n    ? __warn+0x83/0x120\n    ? refcount_warn_saturate+0xb2/0x100\n    ? report_bug+0x158/0x190\n    ? prb_read_valid+0x20/0x30\n    ? handle_bug+0x3e/0x70\n    ? exc_invalid_op+0x1c/0x70\n    ? asm_exc_invalid_op+0x1f/0x30\n    ? refcount_warn_saturate+0xb2/0x100\n    ? refcount_warn_saturate+0xb2/0x100\n    ax25_release+0x2ad/0x360\n    __sock_release+0x35/0xa0\n    sock_close+0x19/0x20\n    [...]\n\nOn reboot (or any attempt to remove the interface), the kernel gets\nstuck in an infinite loop:\n\n    unregister_netdevice: waiting for ax0 to become free. Usage count = 0\n\nThis patch corrects these issues by ensuring that we call netdev_hold()\nand ax25_dev_hold() for new connections in ax25_accept(). This makes the\nlogic leading to ax25_accept() match the logic for ax25_bind(): in both\ncases we increment the refcount, which is ultimately decremented in\nax25_release()."}, {"lang": "es", "value": "En el kernel de Linux, se resolvi\u00f3 la siguiente vulnerabilidad: ax25: corrige el desequilibrio de recuento en conexiones entrantes Al liberar un socket en ax25_release(), llamamos a netdev_put() para disminuir el recuento en el dispositivo ax.25 asociado. Sin embargo, la ruta de ejecuci\u00f3n para aceptar una conexi\u00f3n entrante nunca llama a netdev_hold(). Este desequilibrio conduce a errores de recuento y, en \u00faltima instancia, a fallos del kernel. Un seguimiento de llamada t\u00edpico para la situaci\u00f3n anterior comenzar\u00e1 con uno de los siguientes errores: refcount_t: decrement hit 0; p\u00e9rdida de memoria. refcount_t: desbordamiento insuficiente; use-after-free. Y luego tendr\u00e1 un seguimiento como: Call Trace:  ? show_regs+0x64/0x70? __advertir+0x83/0x120 ? refcount_warn_saturate+0xb2/0x100? report_bug+0x158/0x190? prb_read_valid+0x20/0x30? handle_bug+0x3e/0x70? exc_invalid_op+0x1c/0x70? asm_exc_invalid_op+0x1f/0x30? refcount_warn_saturate+0xb2/0x100? refcount_warn_saturate+0xb2/0x100 ax25_release+0x2ad/0x360 __sock_release+0x35/0xa0 sock_close+0x19/0x20 [...] Al reiniciar (o cualquier intento de eliminar la interfaz), el kernel se atasca en un bucle infinito: unregister_netdevice: esperando ax0 para quedar libre. Recuento de uso = 0 Este parche corrige estos problemas asegurando que llamemos a netdev_hold() y ax25_dev_hold() para nuevas conexiones en ax25_accept(). Esto hace que la l\u00f3gica que conduce a ax25_accept() coincida con la l\u00f3gica de ax25_bind(): en ambos casos incrementamos el refcount, que finalmente disminuye en ax25_release()."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.18", "versionEndExcluding": "6.1.95", "matchCriteriaId": "EFECBC56-DE9A-457A-AE19-CA526A30C054"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.2", "versionEndExcluding": "6.6.35", "matchCriteriaId": "6F019D15-84C0-416B-8C57-7F51B68992F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.7", "versionEndExcluding": "6.9.6", "matchCriteriaId": "0ABBBA1D-F79D-4BDB-AA41-D1EDCC4A6975"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.10:rc1:*:*:*:*:*:*", "matchCriteriaId": "2EBB4392-5FA6-4DA9-9772-8F9C750109FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.10:rc2:*:*:*:*:*:*", "matchCriteriaId": "331C2F14-12C7-45D5-893D-8C52EE38EA10"}]}]}], "references": [{"url": "https://git.kernel.org/stable/c/3c34fb0bd4a4237592c5ecb5b2e2531900c55774", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/52100fd74ad07b53a4666feafff1cd11436362d3", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/a723a6c8d4831cc8e2c7b0c9f3f0c010d4671964", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/f4df9d6c8d4e4c818252b0419c2165d66eabd4eb", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67", "tags": ["Patch"]}], "techniques": [{"techniqueID": "T1190", "comment": "CVE-2024-40910 - This technique is relevant because the vulnerability in the Linux kernel allows attackers to cause a refcount imbalance, leading to kernel crashes. This can be mitigated by ensuring that the correct counter is used when releasing sockets and by using the correct logic for updating the refcount."}, {"techniqueID": "T1102", "comment": "CVE-2024-40910 - This technique is relevant because the vulnerability in the Linux kernel allows attackers to cause a use-after-free condition, leading to further exploitation. This can be mitigated by ensuring that the correct logic is used when freeing and releasing resources."}, {"techniqueID": "T1193", "comment": "CVE-2024-40910 - This technique is relevant because the vulnerability in the Linux kernel allows attackers to cause a kernel hangs or deadlocks, leading to denial of service. This can be mitigated by ensuring that the correct logic is used when handling network traffic and by implementing proper error handling."}], "stix_bundle": {"type": "bundle", "id": "CVE-2024-40910-bundle", "version": "2.1", "modules": [{"type": "packet", "id": "CVE-2024-40910-packet", "title": "CVE-2024-40910: Linux Kernel AX.25 Refcount Imbalance", "description": "This packet provides information about the CVE-2024-40910 vulnerability in the Linux kernel", "indicators": [{"type": "network traffic", "id": "CVE-2024-40910-network-traffic", "description": "Network traffic patterns indicating the execution of the AX.25 protocol"}]}, {"type": "target", "id": "CVE-2024-40910-target", "title": "CVE-2024-40910: Linux Kernel Target", "description": "This target provides information about the Linux kernel AX.25 protocol vulnerable to the CVE-2024-40910 vulnerability", "references": [{"href": "https://git.kernel.org/stable/c/3c34fb0bd4a4237592c5ecb5b2e2531900c55774"}]}, {"type": "course-of-action", "id": "CVE-2024-40910-course-of-action", "title": "CVE-2024-40910: Mitigation Strategies", "description": "Mitigation strategies for the CVE-2024-40910 vulnerability", "techniques": [{"techniqueID": "T1190", "label": "Correcting Refcount Imbalance"}, {"techniqueID": "T1102", "label": "Use-After-Free Correction"}, {"techniqueID": "T1193", "label": "Kernel Hang Prevention"}]}]}, "technical_analysis": {"Introduction": "The CVE-2024-40910 vulnerability is a refcount imbalance in the Linux kernel AX.25 protocol, which can lead to kernel crashes and use-after-free conditions.", "Impact and Scope": "The vulnerability has a CVSS score of 5.5 and is exploitable over the local network. It affects Linux kernel versions 5.18 to 6.1.95, 6.2 to 6.6.35, and 6.7 to 6.9.6.", "Related MITRE ATT&CK Techniques": "Related MITRE ATT&CK techniques include T1190, T1102, and T1193.", "Technical Details": "The vulnerability occurs when the AX.25 protocol is used to handle network traffic, causing a refcount imbalance.", "Detection": "The vulnerability can be detected by monitoring network traffic patterns and identifying potential use-after-free conditions.", "Mitigation": "The vulnerability can be mitigated by implementing the correct logic for updating the refcount and by using the correct counter when releasing sockets.", "Conclusion": "The CVE-2024-40910 vulnerability is a critical security issue that requires immediate attention and mitigation."}, "executive_analysis": {"Overview": "The CVE-2024-40910 vulnerability is a critical security issue that affects the Linux kernel AX.25 protocol.", "Business Impact": "The vulnerability can lead to kernel crashes and use-after-free conditions, which can impact business operations and compromise sensitive data.", "Technical Impact": "The vulnerability affects Linux kernel versions 5.18 to 6.1.95, 6.2 to 6.6.35, and 6.7 to 6.9.6, and can be exploited over the local network.", "Mitigation Strategies": "Implement the correct logic for updating the refcount and use the correct counter when releasing sockets.", "Recommendations": "Implement immediate patching and upgrading to a secure version of the Linux kernel.", "Conclusions": "The CVE-2024-40910 vulnerability is a critical security issue that requires immediate attention and mitigation."}}