{"id": "CVE-2024-45003", "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67", "published": "2024-09-04T20:15:08.823", "lastModified": "2024-09-05T12:53:21.110", "vulnStatus": "Awaiting Analysis", "cveTags": [], "descriptions": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nvfs: Don't evict inode under the inode lru traversing context\n\nThe inode reclaiming process(See function prune_icache_sb) collects all\nreclaimable inodes and mark them with I_FREEING flag at first, at that\ntime, other processes will be stuck if they try getting these inodes\n(See function find_inode_fast), then the reclaiming process destroy the\ninodes by function dispose_list(). Some filesystems(eg. ext4 with\nea_inode feature, ubifs with xattr) may do inode lookup in the inode\nevicting callback function, if the inode lookup is operated under the\ninode lru traversing context, deadlock problems may happen.\n\nCase 1: In function ext4_evict_inode(), the ea inode lookup could happen\n        if ea_inode feature is enabled, the lookup process will be stuck\n\tunder the evicting context like this:\n\n 1. File A has inode i_reg and an ea inode i_ea\n 2. getfattr(A, xattr_buf) // i_ea is added into lru // lru->i_ea\n 3. Then, following three processes running like this:\n\n    PA                              PB\n echo 2 > /proc/sys/vm/drop_caches\n  shrink_slab\n   prune_dcache_sb\n   // i_reg is added into lru, lru->i_ea->i_reg\n   prune_icache_sb\n    list_lru_walk_one\n     inode_lru_isolate\n      i_ea->i_state |= I_FREEING // set inode state\n     inode_lru_isolate\n      __iget(i_reg)\n      spin_unlock(&i_reg->i_lock)\n      spin_unlock(lru_lock)\n                                     rm file A\n                                      i_reg->nlink = 0\n      iput(i_reg) // i_reg->nlink is 0, do evict\n       ext4_evict_inode\n        ext4_xattr_delete_inode\n         ext4_xattr_inode_dec_ref_all\n          ext4_xattr_inode_iget\n           ext4_iget(i_ea->i_ino)\n            iget_locked\n             find_inode_fast\n              __wait_on_freeing_inode(i_ea) ----? AA deadlock\n    dispose_list // cannot be executed by prune_icache_sb\n     wake_up_bit(&i_ea->i_state)\n\nCase 2: In deleted inode writing function ubifs_jnl_write_inode(), file\n        deleting process holds BASEHD's wbuf->io_mutex while getting the\n\txattr inode, which could race with inode reclaiming process(The\n        reclaiming process could try locking BASEHD's wbuf->io_mutex in\n\tinode evicting function), then an ABBA deadlock problem would\n\thappen as following:\n\n 1. File A has inode ia and a xattr(with inode ixa), regular file B has\n    inode ib and a xattr.\n 2. getfattr(A, xattr_buf) // ixa is added into lru // lru->ixa\n 3. Then, following three processes running like this:\n\n        PA                PB                        PC\n                echo 2 > /proc/sys/vm/drop_caches\n                 shrink_slab\n                  prune_dcache_sb\n                  // ib and ia are added into lru, lru->ixa->ib->ia\n                  prune_icache_sb\n                   list_lru_walk_one\n                    inode_lru_isolate\n                     ixa->i_state |= I_FREEING // set inode state\n                    inode_lru_isolate\n                     __iget(ib)\n                     spin_unlock(&ib->i_lock)\n                     spin_unlock(lru_lock)\n                                                   rm file B\n                                                    ib->nlink = 0\n rm file A\n  iput(ia)\n   ubifs_evict_inode(ia)\n    ubifs_jnl_delete_inode(ia)\n     ubifs_jnl_write_inode(ia)\n      make_reservation(BASEHD) // Lock wbuf->io_mutex\n      ubifs_iget(ixa->i_ino)\n       iget_locked\n        find_inode_fast\n         __wait_on_freeing_inode(ixa)\n          |          iput(ib) // ib->nlink is 0, do evict\n          |           ubifs_evict_inode\n          |            ubifs_jnl_delete_inode(ib)\n          ?             ubifs_jnl_write_inode\n     ABBA deadlock ?-----make_reservation(BASEHD)\n                   dispose_list // cannot be executed by prune_icache_sb\n                    wake_up_bit(&ixa->i_state)\n\nFix the possible deadlock by using new inode state flag I_LRU_ISOLATING\nto pin the inode in memory while inode_lru_isolate(\n---truncated---"}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: vfs: No desalojar inodo bajo el contexto de recorrido lru de inodo El proceso de recuperaci\u00f3n de inodo (ver funci\u00f3n prune_icache_sb) recopila todos los inodos recuperables y los marca con el indicador I_FREEING al principio, en ese momento, otros procesos se atascar\u00e1n si intentan obtener estos inodos (ver funci\u00f3n find_inode_fast), luego el proceso de recuperaci\u00f3n destruye los inodos mediante la funci\u00f3n dispose_list(). Algunos sistemas de archivos (por ejemplo, ext4 con la funci\u00f3n ea_inode, ubifs con xattr) pueden realizar una b\u00fasqueda de inodo en la funci\u00f3n de devoluci\u00f3n de llamada de expulsi\u00f3n de inodo, si la b\u00fasqueda de inodo se opera bajo el contexto de recorrido lru de inodo, pueden ocurrir problemas de interbloqueo. Caso 1: En la funci\u00f3n ext4_evict_inode(), la b\u00fasqueda de inodo ea podr\u00eda ocurrir si la caracter\u00edstica ea_inode est\u00e1 habilitada, el proceso de b\u00fasqueda se quedar\u00e1 atascado bajo el contexto de desalojo de esta manera: 1. El archivo A tiene un inodo i_reg y un inodo ea i_ea 2. getfattr(A, xattr_buf) // i_ea se agrega a lru // lru-&gt;i_ea 3. Luego, los siguientes tres procesos se ejecutan de esta manera: PA PB echo 2 &gt; /proc/sys/vm/drop_caches shrink_slab prune_dcache_sb // i_reg se agrega a lru, lru-&gt;i_ea-&gt;i_reg prune_icache_sb list_lru_walk_one inode_lru_isolate i_ea-&gt;i_state |= I_FREEING // establece el estado del inodo inode_lru_isolate __iget(i_reg) spin_unlock(&amp;i_reg-&gt;i_lock) spin_unlock(lru_lock) rm archivo A i_reg-&gt;nlink = 0 iput(i_reg) // i_reg-&gt;nlink es 0, desalojar ext4_evict_inode ext4_xattr_delete_inode ext4_xattr_inode_dec_ref_all ext4_xattr_inode_iget ext4_iget(i_ea-&gt;i_ino) iget_locked find_inode_fast __wait_on_freeing_inode(i_ea) ----? Bloqueo AA dispose_list // no puede ser ejecutado por prune_icache_sb wake_up_bit(&amp;i_ea-&gt;i_state) Caso 2: En la funci\u00f3n de escritura de inodo eliminado ubifs_jnl_write_inode(), el proceso de eliminaci\u00f3n de archivo retiene BASEHD wbuf-&gt;io_mutex mientras obtiene el inodo xattr, que podr\u00eda competir con el proceso de recuperaci\u00f3n de inodo (el proceso de recuperaci\u00f3n podr\u00eda intentar bloquear wbuf-&gt;io_mutex de BASEHD en la funci\u00f3n de desalojo de inodo), entonces ocurrir\u00eda un problema de bloqueo ABBA de la siguiente manera: 1. El archivo A tiene un inodo ia y un xattr (con un inodo ixa), el archivo B normal tiene un inodo ib y un xattr. 2. getfattr(A, xattr_buf) // ixa se agrega a lru // lru-&gt;ixa 3. Luego, los siguientes tres procesos se ejecutan de esta manera: PA PB PC echo 2 &gt; /proc/sys/vm/drop_caches shrink_slab prune_dcache_sb // ib e ia se agregan a lru, lru-&gt;ixa-&gt;ib-&gt;ia prune_icache_sb list_lru_walk_one inode_lru_isolate ixa-&gt;i_state |= I_FREEING // establece el estado del inodo inode_lru_isolate __iget(ib) spin_unlock(&amp;ib-&gt;i_lock) spin_unlock(lru_lock) rm archivo B ib-&gt;nlink = 0 rm archivo A iput(ia) ubifs_evict_inode(ia) ubifs_jnl_delete_inode(ia) ubifs_jnl_write_inode(ia) make_reservation(BASEHD) // Bloquear wbuf-&gt;io_mutex ubifs_iget(ixa-&gt;i_ino) iget_locked find_inode_fast __wait_on_freeing_inode(ixa) | iput(ib) // ib-&gt;nlink es 0, desalojar | ubifs_evict_inode | ubifs_jnl_delete_inode(ib) ? ubifs_jnl_write_inode Bloqueo ABBA ?-----make_reservation(BASEHD) dispose_list // no puede ser ejecutado por prune_icache_sb wake_up_bit(&amp;ixa-&gt;i_state) Corrija el posible bloqueo utilizando el nuevo indicador de estado de inodo I_LRU_ISOLATING para fijar el inodo en la memoria mientras inode_lru_isolate( ---truncado---"}], "metrics": {}, "references": [{"url": "https://git.kernel.org/stable/c/03880af02a78bc9a98b5a581f529cf709c88a9b8", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/2a0629834cd82f05d424bbc193374f9a43d1f87d", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/3525ad25240dfdd8c78f3470911ed10aa727aa72", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/437741eba63bf4e437e2beb5583f8633556a2b98", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/9063ab49c11e9518a3f2352434bb276cc8134c5f", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/b9bda5f6012dd00372f3a06a82ed8971a4c57c32", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/cda54ec82c0f9d05393242b20b13f69b083f7e88", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}], "techniques": [{"techniqueID": "T1027", "comment": "CVE-2024-45003 - Potential Use of Deadlock to Deny Service: Used to create a deadlock by acquiring and holding resources in a way that prevents other processes from continuing. This technique can be used to deny service to legitimate users."}, {"techniqueID": "T1190", "comment": "CVE-2024-45003 - Exploit Public-Facing Application: This technique can be used to identify and exploit vulnerable applications that are accessible from the Internet. In this case, the vulnerability is in a Linux kernel module."}], "stix_bundle": {"type": "bundle", "id": "urn:stix:bundle:1.2.3", "label": "CVE-2024-45003 Analysis", "description": "STIX Bundle for CVE-2024-45003", "created": "2024-09-05T12:53:21.110", "modified": "2024-09-05T12:53:21.110", "objects": [{"type": "vulnerability", "id": "urn:stix:vulnerability:1.2.3", "label": "CVE-2024-45003", "description": "Linux Kernel Module Vulnerability", "cvss_SCORE": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "references": [{"id": "urn:stix:reference:1.2.3", "type": "reference", "label": "Linux Kernel Module Vulnerability"}], "relationship": {"relationship": "related_to", "end1": {"type": "vulnerability", "id": "urn:stix:vulnerability:1.2.3"}, "end2": {"type": "mitigation", "id": "urn:stix:mitigation:1.2.3"}}}, {"type": "mitigation", "id": "urn:stix:mitigation:1.2.3", "label": "Patch Linux Kernel Module", "description": "Apply the latest patch to the Linux kernel module", "relationship": {"relationship": "mitigates", "end1": {"type": "vulnerability", "id": "urn:stix:vulnerability:1.2.3"}, "end2": {"type": "mitigation", "id": "urn:stix:mitigation:1.2.3"}}}]}, "technical_analysis": {"Introduction": "The vulnerability allows an attacker to create a deadlock by acquiring and holding resources in a way that prevents other processes from continuing. This can be used to deny service to legitimate users.", "Impact and Scope": "The vulnerability has a CVSS score of 9.8 and affects Linux kernel modules. The attack vector is network-based and requires a specific set of conditions to be met.", "Related MITRE ATT&CK Techniques": "T1027 and T1190", "Technical Details": "The vulnerability occurs when the Linux kernel module is used in a specific way that allows an attacker to create a deadlock. This can be achieved by acquiring and holding resources in a way that prevents other processes from continuing.", "Detection": "Detecting this vulnerability requires monitoring system calls and tracking resource allocation. A network-based attack can be detected by monitoring network traffic and identifying suspicious patterns.", "Mitigation": "The vulnerability can be mitigated by applying the latest patch to the Linux kernel module. This will prevent the deadlock from occurring and prevent the attacker from denying service.", "Conclusion": "In conclusion, the vulnerability is a serious issue that requires immediate attention. Applying the latest patch to the Linux kernel module is the most effective way to mitigate the vulnerability."}, "executive_analysis": {"Overview": "The vulnerability is a Linux kernel module that allows an attacker to create a deadlock, which can be used to deny service to legitimate users.", "Business Impact": "The vulnerability can result in significant financial losses and damage to reputation.", "Technical Impact": "The vulnerability can result in system crashes, data corruption, and denial of service.", "Mitigation Strategies": "Apply the latest patch to the Linux kernel module.", "Recommendations": "Apply the latest patch to the Linux kernel module and monitor system calls and resource allocation.", "Conclusions": "In conclusion, the vulnerability is a serious issue that requires immediate attention. Applying the latest patch to the Linux kernel module is the most effective way to mitigate the vulnerability."}}