{"id": "CVE-2024-26737", "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67", "published": "2024-04-03T17:15:51.243", "lastModified": "2024-04-03T17:24:18.150", "vulnStatus": "Awaiting Analysis", "cveTags": [], "descriptions": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix racing between bpf_timer_cancel_and_free and bpf_timer_cancel\n\nThe following race is possible between bpf_timer_cancel_and_free\nand bpf_timer_cancel. It will lead a UAF on the timer->timer.\n\nbpf_timer_cancel();\n\tspin_lock();\n\tt = timer->time;\n\tspin_unlock();\n\n\t\t\t\t\tbpf_timer_cancel_and_free();\n\t\t\t\t\t\tspin_lock();\n\t\t\t\t\t\tt = timer->timer;\n\t\t\t\t\t\ttimer->timer = NULL;\n\t\t\t\t\t\tspin_unlock();\n\t\t\t\t\t\thrtimer_cancel(&t->timer);\n\t\t\t\t\t\tkfree(t);\n\n\t/* UAF on t */\n\thrtimer_cancel(&t->timer);\n\nIn bpf_timer_cancel_and_free, this patch frees the timer->timer\nafter a rcu grace period. This requires a rcu_head addition\nto the \"struct bpf_hrtimer\". Another kfree(t) happens in bpf_timer_init,\nthis does not need a kfree_rcu because it is still under the\nspin_lock and timer->timer has not been visible by others yet.\n\nIn bpf_timer_cancel, rcu_read_lock() is added because this helper\ncan be used in a non rcu critical section context (e.g. from\na sleepable bpf prog). Other timer->timer usages in helpers.c\nhave been audited, bpf_timer_cancel() is the only place where\ntimer->timer is used outside of the spin_lock.\n\nAnother solution considered is to mark a t->flag in bpf_timer_cancel\nand clear it after hrtimer_cancel() is done.  In bpf_timer_cancel_and_free,\nit busy waits for the flag to be cleared before kfree(t). This patch\ngoes with a straight forward solution and frees timer->timer after\na rcu grace period."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: bpf: Correcci\u00f3n de ejecuci\u00f3ns entre bpf_timer_cancel_and_free y bpf_timer_cancel La siguiente ejecuci\u00f3n es posible entre bpf_timer_cancel_and_free y bpf_timer_cancel. Dirigir\u00e1 una UAF en el temporizador-&gt;temporizador. bpf_timer_cancel(); spin_lock(); t = temporizador-&gt;tiempo; spin_unlock(); bpf_timer_cancel_and_free(); spin_lock(); t = temporizador-&gt;temporizador; temporizador-&gt;temporizador = NULL; spin_unlock(); hrtimer_cancel(&amp;t-&gt;temporizador); klibre(t); /* UAF en t */ hrtimer_cancel(&amp;t-&gt;timer); En bpf_timer_cancel_and_free, este parche libera el temporizador-&gt;temporizador despu\u00e9s de un per\u00edodo de gracia de rcu. Esto requiere una adici\u00f3n de rcu_head a \"struct bpf_hrtimer\". Otro kfree(t) ocurre en bpf_timer_init, esto no necesita un kfree_rcu porque todav\u00eda est\u00e1 bajo spin_lock y otros a\u00fan no han visible el temporizador-&gt;temporizador. En bpf_timer_cancel, se agrega rcu_read_lock() porque este asistente puede usarse en un contexto de secci\u00f3n no cr\u00edtica para rcu (por ejemplo, desde un programa bpf que se puede dormir). Se han auditado otros usos de temporizador-&gt;temporizador en helpers.c, bpf_timer_cancel() es el \u00fanico lugar donde se usa temporizador-&gt;temporizador fuera de spin_lock. Otra soluci\u00f3n considerada es marcar una bandera t-&gt; en bpf_timer_cancel y borrarla una vez finalizado hrtimer_cancel(). En bpf_timer_cancel_and_free, est\u00e1 ocupado esperando a que se borre la bandera antes de kfree(t). Este parche incluye una soluci\u00f3n sencilla y libera el temporizador-&gt;temporizador despu\u00e9s de un per\u00edodo de gracia de rcu."}], "metrics": {}, "references": [{"url": "https://git.kernel.org/stable/c/0281b919e175bb9c3128bd3872ac2903e9436e3f", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/5268bb02107b9eedfdcd51db75b407d10043368c", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/7d80a9e745fa5b47da3bca001f186c02485c7c33", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/8327ed12e8ebc5436bfaa1786c49988894f9c8a6", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/addf5e297e6cbf5341f9c07720693ca9ba0057b5", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}], "techniques": [{"techniqueID": "T1221", "comment": "CVE-2024-26737 - The 'bpf_timer_cancel_and_free' function has a race condition that can lead to a UAF, allowing for potential exploitation through a crafted bpf program. Defenders should look for abnormal program behavior and monitor CPU usage to detect and mitigate this attack."}, {"techniqueID": "T1204", "comment": "CVE-2024-26737 - The race condition in the 'bpf_timer_cancel_and_free' function can be exploited to gain arbitrary memory access and potentially execute arbitrary code. Defenders should implement memory protection mechanisms and monitor system calls to detect and prevent this attack."}], "stix_bundle": {"@stix2_version": "2.1", "id": "https://example.com/bundle/cve-2024-26737", "type": "bundle", "objects": [{"id": "https://example.com/object/cve-2024-26737", "type": "vulnerability", "name": "CVE-2024-26737", "description": "Race condition in the 'bpf_timer_cancel_and_free' function can lead to UAF and arbitrary memory access.", "related_components": [{"id": "https://example.com/object/bpf_timer_cancel_and_free", "type": "function", "name": "bpf_timer_cancel_and_free", "description": "Function with race condition"}], " exploits": [{"id": "https://example.com/object/exploit-1", "type": "exploit", "name": "Exploit 1", "description": "Exploit the race condition to gain arbitrary memory access"}]}, {"id": "https://example.com/object/technique-1", "type": "attack-pattern", "name": "T1221 - Data Staged", "description": "Data staged for execution", "related_vulnerabilities": [{"id": "https://example.com/object/cve-2024-26737", "type": "vulnerability", "name": "CVE-2024-26737"}]}, {"id": "https://example.com/object/technique-2", "type": "attack-pattern", "name": "T1204 - User Execution", "description": "User execution of malicious code", "related_vulnerabilities": [{"id": "https://example.com/object/cve-2024-26737", "type": "vulnerability", "name": "CVE-2024-26737"}]}, {"id": "https://example.com/object/detection-1", "type": "indicator", "name": "Detection 1", "description": "Anomalous program behavior or CPU usage", "related-vulnerabilities": [{"id": "https://example.com/object/cve-2024-26737", "type": "vulnerability", "name": "CVE-2024-26737"}]}, {"id": "https://example.com/object/mitigation-1", "type": "course-of-action", "name": "Mitigation 1", "description": "Implement memory protection mechanisms", "related_vulnerabilities": [{"id": "https://example.com/object/cve-2024-26737", "type": "vulnerability", "name": "CVE-2024-26737"}]}], "relationships": [{"id": "https://example.com/relationship/1", "type": "has-part", "source_ref": "https://example.com/object/cve-2024-26737", "target_ref": "https://example.com/object/bpf_timer_cancel_and_free"}, {"id": "https://example.com/relationship/2", "type": "exploits", "source_ref": "https://example.com/object/exploit-1", "target_ref": "https://example.com/object/cve-2024-26737"}]}, "technical_analysis": {"Introduction": "This vulnerability is a race condition in the 'bpf_timer_cancel_and_free' function that can lead to UAF and arbitrary memory access.", "Impact and Scope": "CVSS score: 8.5, Attack vector: network", "Related MITRE ATT&CK Techniques": "T1221, T1204", "Technical Details": "The race condition is caused by the lack of synchronization between the 'bpf_timer_cancel_and_free' function and other parts of the kernel.", "Detection": "Monitor for abnormal program behavior and CPU usage", "Mitigation": "Implement memory protection mechanisms", "Conclusion": "The vulnerability can be exploited to gain arbitrary memory access and potentially execute arbitrary code."}, "executive_analysis": {"Overview": "This vulnerability poses a significant risk to organizations that rely on Linux systems.", "Business Impact": "Potential data breaches or system compromise", "Technical Impact": "Arbitrary memory access and code execution", "Mitigation Strategies": "Implement memory protection mechanisms and monitor system calls", "Recommendations": "Patch the vulnerability as soon as possible", "Conclusions": "The vulnerability is a critical risk that requires immediate attention."}}