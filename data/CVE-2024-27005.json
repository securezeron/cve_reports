{"id": "CVE-2024-27005", "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67", "published": "2024-05-01T06:15:18.883", "lastModified": "2024-05-13T08:15:11.680", "vulnStatus": "Awaiting Analysis", "cveTags": [], "descriptions": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ninterconnect: Don't access req_list while it's being manipulated\n\nThe icc_lock mutex was split into separate icc_lock and icc_bw_lock\nmutexes in [1] to avoid lockdep splats. However, this didn't adequately\nprotect access to icc_node::req_list.\n\nThe icc_set_bw() function will eventually iterate over req_list while\nonly holding icc_bw_lock, but req_list can be modified while only\nholding icc_lock. This causes races between icc_set_bw(), of_icc_get(),\nand icc_put().\n\nExample A:\n\n  CPU0                               CPU1\n  ----                               ----\n  icc_set_bw(path_a)\n    mutex_lock(&icc_bw_lock);\n                                     icc_put(path_b)\n                                       mutex_lock(&icc_lock);\n    aggregate_requests()\n      hlist_for_each_entry(r, ...\n                                       hlist_del(...\n        <r = invalid pointer>\n\nExample B:\n\n  CPU0                               CPU1\n  ----                               ----\n  icc_set_bw(path_a)\n    mutex_lock(&icc_bw_lock);\n                                     path_b = of_icc_get()\n                                       of_icc_get_by_index()\n                                         mutex_lock(&icc_lock);\n                                         path_find()\n                                           path_init()\n    aggregate_requests()\n      hlist_for_each_entry(r, ...\n                                             hlist_add_head(...\n        <r = invalid pointer>\n\nFix this by ensuring icc_bw_lock is always held before manipulating\nicc_node::req_list. The additional places icc_bw_lock is held don't\nperform any memory allocations, so we should still be safe from the\noriginal lockdep splats that motivated the separate locks.\n\n[1] commit af42269c3523 (\"interconnect: Fix locking for runpm vs reclaim\")"}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: interconexi\u00f3n: no acceder a req_list mientras se est\u00e1 manipulando. El mutex icc_lock se dividi\u00f3 en mutex icc_lock e icc_bw_lock separados en [1] para evitar s\u00edmbolos de bloqueo. Sin embargo, esto no protegi\u00f3 adecuadamente el acceso a icc_node::req_list. La funci\u00f3n icc_set_bw() eventualmente iterar\u00e1 sobre req_list mientras solo mantiene icc_bw_lock, pero req_list se puede modificar mientras solo mantiene icc_lock. Esto provoca ejecuci\u00f3ns entre icc_set_bw(), of_icc_get() e icc_put(). Ejemplo A: CPU0 CPU1 ---- ---- icc_set_bw(path_a) mutex_lock(&amp;icc_bw_lock); icc_put(ruta_b) mutex_lock(&amp;icc_lock); agregado_requests() hlist_for_each_entry(r, ... hlist_del(...  Ejemplo B: CPU0 CPU1 ---- ---- icc_set_bw(path_a) mutex_lock(&amp;icc_bw_lock); path_b = of_icc_get() of_icc_get_by_index( ) mutex_lock(&amp;icc_lock); path_find() path_init() agregado_requests() hlist_for_each_entry(r, ... hlist_add_head(...  Solucione este problema asegur\u00e1ndose de que icc_bw_lock siempre se mantenga antes de manipular icc_node::req_list. El adicional Los lugares donde se mantiene icc_bw_lock no realizan ninguna asignaci\u00f3n de memoria, por lo que a\u00fan deber\u00edamos estar a salvo de los s\u00edmbolos de bloqueo originales que motivaron los bloqueos separados [1] commit af42269c3523 (\"interconexi\u00f3n: arreglar el bloqueo para runpm vs reclaim\")"}], "metrics": {}, "references": [{"url": "https://git.kernel.org/stable/c/4c65507121ea8e0b47fae6d2049c8688390d46b6", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/d0d04efa2e367921654b5106cc5c05e3757c2b42", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/de1bf25b6d771abdb52d43546cf57ad775fb68a1", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}], "techniques": [{"techniqueID": "T1190", "comment": "This technique is relevant because it involves race condition vulnerability in the Linux kernel which could allow attackers to manipulate icc_node::req_list, leading to system crashes or other malicious activities. This could be mitigated by ensuring icc_bw_lock is always held before manipulating icc_node::req_list."}, {"techniqueID": "T1390", "comment": "This technique is relevant because it involves a mismatch between the access to icc_node::req_list and the locking mechanism, which could be exploited by attackers to access and manipulate system memory. This could be mitigated by implementing proper locking mechanisms to protect access to system memory."}, {"techniqueID": "T1560", "comment": "This technique is relevant because it involves a denial-of-service vulnerability in the Linux kernel which could be exploited by attackers to crash the system or deny legitimate users access to system resources. This could be mitigated by implementing proper error handling mechanisms to prevent system crashes and denying access to system resources."}], "stix_bundle": {"objects": [{"type": "vulnerability", "id": "CVE-2024-27005", "startDate": "2024-05-01T06:15:18.883", "endDate": "2024-05-01T06:15:18.883", "name": "CVE-2024-27005: Linux kernel interconnect vulnerability", "description": "A vulnerability in the Linux kernel interconnect component allows attackers to manipulate icc_node::req_list, leading to system crashes or other malicious activities.", "external_references": [{"source_name": "CVE", "external_id": "CVE-2024-27005"}]}, {"type": "observable", "id": "observable-1", "href": "https://git.kernel.org/stable/c/4c65507121ea8e0b47fae6d2049c8688390d46b6", "name": "Git commit that resolved the issue"}, {"type": "observable", "id": "observable-2", "href": "https://git.kernel.org/stable/c/d0d04efa2e367921654b5106cc5c05e3757c2b42", "name": "Git commit that resolved the issue"}, {"type": "observable", "id": "observable-3", "href": "https://git.kernel.org/stable/c/de1bf25b6d771abdb52d43546cf57ad775fb68a1", "name": "Git commit that resolved the issue"}, {"type": "course-of-action", "id": "course-of-action-1", "name": "Apply the latest updates to the Linux kernel", "description": "Apply the latest updates to the Linux kernel to mitigate the vulnerability.", "object_refs": ["#CVE-2024-27005"]}, {"type": "course-of-action", "id": "course-of-action-2", "name": "Use a patch to fix the vulnerability", "description": "Use a patch to fix the vulnerability.", "object_refs": ["#CVE-2024-27005"]}], "relationships": [{"relationship_type": "related-to", "source_ref": "#CVE-2024-27005", "target_ref": "#course-of-action-1"}, {"relationship_type": "related-to", "source_ref": "#CVE-2024-27005", "target_ref": "#course-of-action-2"}]}, "technical_analysis": {"Introduction": "The Linux kernel interconnect component has a race condition vulnerability that allows attackers to manipulate icc_node::req_list, leading to system crashes or other malicious activities.", "Impact and Scope": "This vulnerability affects the Linux kernel and could be exploited by attackers to manipulate icc_node::req_list, leading to system crashes or other malicious activities. The CVSS score is 5.9, the attack vector is remote, and the attack complexity is high.", "Related MITRE ATT&CK Techniques": "This vulnerability is related to the MITRE ATT&CK techniques T1190, T1390, and T1560.", "Technical Details": "The vulnerability occurs because the icc_set_bw() function iterates over req_list while only holding icc_bw_lock, but req_list can be modified while only holding icc_lock. This causes races between icc_set_bw(), of_icc_get(), and icc_put().", "Detection": "The vulnerability can be detected by analyzing system calls and network traffic for signs of malicious activity.", "Mitigation": "This vulnerability can be mitigated by applying the latest updates to the Linux kernel or using a patch to fix the vulnerability.", "Conclusion": "In conclusion, this vulnerability in the Linux kernel interconnect component can be exploited by attackers to manipulate icc_node::req_list, leading to system crashes or other malicious activities. It is important to apply the latest updates to the Linux kernel or use a patch to fix the vulnerability to mitigate this vulnerability."}, "executive_analysis": {"Overview": "The Linux kernel interconnect component has a race condition vulnerability that allows attackers to manipulate icc_node::req_list, leading to system crashes or other malicious activities.", "Business Impact": "This vulnerability could have a significant impact on business operations if exploited by attackers, potentially leading to system crashes or other malicious activities.", "Technical Impact": "This vulnerability could also have a technical impact on the Linux kernel and its components, potentially leading to system crashes or other malicious activities.", "Mitigation Strategies": "The mitigation strategies for this vulnerability include applying the latest updates to the Linux kernel or using a patch to fix the vulnerability.", "Recommendations": "Recommendations for executives include applying the latest updates to the Linux kernel or using a patch to fix the vulnerability, and conducting a thorough risk assessment to determine the potential impact of this vulnerability on business operations.", "Conclusions": "In conclusion, this vulnerability in the Linux kernel interconnect component is a significant risk to system security and business operations. It is important to take immediate action to mitigate this vulnerability by applying the latest updates to the Linux kernel or using a patch to fix the vulnerability."}}