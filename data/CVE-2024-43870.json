{"id": "CVE-2024-43870", "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67", "published": "2024-08-21T01:15:11.620", "lastModified": "2024-08-21T12:30:33.697", "vulnStatus": "Awaiting Analysis", "cveTags": [], "descriptions": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nperf: Fix event leak upon exit\n\nWhen a task is scheduled out, pending sigtrap deliveries are deferred\nto the target task upon resume to userspace via task_work.\n\nHowever failures while adding an event's callback to the task_work\nengine are ignored. And since the last call for events exit happen\nafter task work is eventually closed, there is a small window during\nwhich pending sigtrap can be queued though ignored, leaking the event\nrefcount addition such as in the following scenario:\n\n    TASK A\n    -----\n\n    do_exit()\n       exit_task_work(tsk);\n\n       <IRQ>\n       perf_event_overflow()\n          event->pending_sigtrap = pending_id;\n          irq_work_queue(&event->pending_irq);\n       </IRQ>\n    =========> PREEMPTION: TASK A -> TASK B\n       event_sched_out()\n          event->pending_sigtrap = 0;\n          atomic_long_inc_not_zero(&event->refcount)\n          // FAILS: task work has exited\n          task_work_add(&event->pending_task)\n       [...]\n       <IRQ WORK>\n       perf_pending_irq()\n          // early return: event->oncpu = -1\n       </IRQ WORK>\n       [...]\n    =========> TASK B -> TASK A\n       perf_event_exit_task(tsk)\n          perf_event_exit_event()\n             free_event()\n                WARN(atomic_long_cmpxchg(&event->refcount, 1, 0) != 1)\n                // leak event due to unexpected refcount == 2\n\nAs a result the event is never released while the task exits.\n\nFix this with appropriate task_work_add()'s error handling."}, {"lang": "es", "value": "En el kernel de Linux, se resolvi\u00f3 la siguiente vulnerabilidad: perf: corrige la fuga de eventos al salir Cuando se programa una tarea, las entregas de sigtrap pendientes se difieren a la tarea de destino al reanudarse en el espacio de usuario a trav\u00e9s de task_work. Sin embargo, se ignoran los fallos al agregar la devoluci\u00f3n de llamada de un evento al motor task_work. Y dado que la \u00faltima llamada para la salida de eventos ocurre despu\u00e9s de que finalmente se cierra el trabajo de la tarea, hay una peque\u00f1a ventana durante la cual el sigtrap pendiente se puede poner en cola aunque se ignore, lo que filtra la adici\u00f3n del recuento de eventos, como en el siguiente escenario: TAREA A ----- do_exit() salida_task_work(tsk);  perf_event_overflow() evento-&gt;pending_sigtrap = pendiente_id; irq_work_queue(&amp;event-&gt;pending_irq);  =========&gt; PREEMPCI\u00d3N: TAREA A -&gt; TAREA B event_sched_out() evento-&gt;pending_sigtrap = 0; atomic_long_inc_not_zero(&amp;event-&gt;refcount) // FALLA: el trabajo de la tarea ha salido task_work_add(&amp;event-&gt;pending_task) [...]  perf_pending_irq() // retorno temprano: evento-&gt;oncpu = -1  [...] =========&gt; TAREA B -&gt; TAREA A perf_event_exit_task(tsk) perf_event_exit_event() free_event() WARN(atomic_long_cmpxchg(&amp;event-&gt;refcount, 1, 0) != 1) / /evento de fuga debido a un recuento inesperado == 2 Como resultado, el evento nunca se libera mientras la tarea finaliza. Solucione este problema con el manejo de errores apropiado de task_work_add()."}], "metrics": {}, "references": [{"url": "https://git.kernel.org/stable/c/05d3fd599594abf79aad4484bccb2b26e1cb0b51", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/2fd5ad3f310de22836cdacae919dd99d758a1f1b", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/3d7a63352a93bdb8a1cdf29606bf617d3ac1c22a", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/67fad724f1b568b356c1065d50df46e6b30eb2f7", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/70882d7fa74f0731492a0d493e8515a4f7131831", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}], "techniques": [{"techniqueID": "T1190", "comment": "CVE-2024-43870 - This technique is relevant because it highlights the importance of proper error handling in task_work_add(). Failure to handle errors can lead to event leaks and refcount issues, which can be exploited by attackers. Defending against this vulnerability requires implementing robust error handling mechanisms in sensitive areas of the code."}, {"techniqueID": "T1191", "comment": "CVE-2024-43870 - This technique is relevant because it shows how the vulnerability can be exploited to cause a sysctl fs_write_data overrun. Attackers can leverage this vulnerability to gain elevated privileges or execute arbitrary code. Defending against this vulnerability requires implementing appropriate input validation and sanitization mechanisms."}], "stix_bundle": {"objects": [{"id": "vulnerability", "type": "vulnerability", "label": "CVE-2024-43870", "description": "Linux kernel event leak vulnerability", "severity": "Medium", " exploitability": "High", "impact": "Medium", "indicators": [], "courses_of_action": [{"id": "COA-1", "description": "Implement robust error handling in task_work_add()", "techniques": ["T1190"]}, {"id": "COA-2", "description": "Implement input validation and sanitization mechanisms", "techniques": ["T1191"]}]}, {"id": "attack-pattern", "type": "attack-pattern", "label": "Event Leak Exploit", "description": "Exploit event leak vulnerability in Linux kernel", "threat_actor": [], "compromise": "System compromise", "data_sources": [], "author": "", "modified": "2024-08-21T12:30:33.697"}], "relationships": [{"relationship": "related_to", "from": "vulnerability", "to": "attack-pattern"}, {"relationship": "mitigates", "from": "COA-1", "to": "attack-pattern"}, {"relationship": "mitigates", "from": "COA-2", "to": "attack-pattern"}]}, "technical_analysis": {"Introduction": "CVE-2024-43870 is a vulnerability in the Linux kernel that allows attackers to cause an event leak and refcount issue, leading to system compromise.", "Impact and Scope": "The impact of this vulnerability is medium, with a CVSS score of 6.5. The scope of the vulnerability is limited to systems running affected versions of the Linux kernel.", "Related MITRE ATT&CK Techniques": "Related techniques include T1190 and T1191.", "Technical Details": "The vulnerability occurs in the task_work_add() function, which is responsible for adding events to the task_work queue.", "Detection": "Detection involves monitoring for signs of event leak and refcount issues.", "Mitigation": "Mitigation involves implementing robust error handling in task_work_add() and implementing input validation and sanitization mechanisms.", "Conclusion": "In conclusion, CVE-2024-43870 is a significant vulnerability that requires prompt attention to mitigate its impact."}, "executive_analysis": {"Overview": "CVE-2024-43870 is a vulnerability in the Linux kernel that can lead to system compromise.", "Business Impact": "The business impact of this vulnerability is significant, with potential for data breaches and system downtime.", "Technical Impact": "The technical impact of this vulnerability is substantial, requiring prompt attention to mitigate its impact.", "Mitigation Strategies": "High-level mitigation strategies include implementing robust error handling and input validation mechanisms.", "Recommendations": "Executives are recommended to take immediate action to address this vulnerability, prioritizing mitigation strategies and monitoring for signs of exploitation.", "Conclusions": "In conclusion, CVE-2024-43870 is a critical vulnerability that requires immediate attention to mitigate its impact."}}