{"id": "CVE-2024-41067", "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67", "published": "2024-07-29T15:15:14.560", "lastModified": "2024-07-29T16:21:52.517", "vulnStatus": "Awaiting Analysis", "cveTags": [], "descriptions": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: scrub: handle RST lookup error correctly\n\n[BUG]\nWhen running btrfs/060 with forced RST feature, it would crash the\nfollowing ASSERT() inside scrub_read_endio():\n\n\tASSERT(sector_nr < stripe->nr_sectors);\n\nBefore that, we would have tree dump from\nbtrfs_get_raid_extent_offset(), as we failed to find the RST entry for\nthe range.\n\n[CAUSE]\nInside scrub_submit_extent_sector_read() every time we allocated a new\nbbio we immediately called btrfs_map_block() to make sure there was some\nRST range covering the scrub target.\n\nBut if btrfs_map_block() fails, we immediately call endio for the bbio,\nwhile the bbio is newly allocated, it's completely empty.\n\nThen inside scrub_read_endio(), we go through the bvecs to find\nthe sector number (as bi_sector is no longer reliable if the bio is\nsubmitted to lower layers).\n\nAnd since the bio is empty, such bvecs iteration would not find any\nsector matching the sector, and return sector_nr == stripe->nr_sectors,\ntriggering the ASSERT().\n\n[FIX]\nInstead of calling btrfs_map_block() after allocating a new bbio, call\nbtrfs_map_block() first.\n\nSince our only objective of calling btrfs_map_block() is only to update\nstripe_len, there is really no need to do that after btrfs_alloc_bio().\n\nThis new timing would avoid the problem of handling empty bbio\ncompletely, and in fact fixes a possible race window for the old code,\nwhere if the submission thread is the only owner of the pending_io, the\nscrub would never finish (since we didn't decrease the pending_io\ncounter).\n\nAlthough the root cause of RST lookup failure still needs to be\naddressed."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: btrfs: Scrub: maneja correctamente el error de b\u00fasqueda RST [ERROR] Al ejecutar btrfs/060 con la funci\u00f3n RST forzada, bloquear\u00eda el siguiente ASSERT() dentro de Scrub_read_endio(): ASSERT(sector_nr &lt; raya-&gt;nr_sectors); Antes de eso, tendr\u00edamos un volcado de \u00e1rbol de btrfs_get_raid_extent_offset(), ya que no pudimos encontrar la entrada RST para el rango. [CAUSA] Dentro de Scrub_submit_extent_sector_read() cada vez que asignamos un nuevo bbio llamamos inmediatamente a btrfs_map_block() para asegurarnos de que hubiera alg\u00fan rango RST que cubriera el objetivo de limpieza. Pero si btrfs_map_block()fallo, inmediatamente llamamos a endio para el bbio, mientras el bbio est\u00e1 reci\u00e9n asignado, est\u00e1 completamente vac\u00edo. Luego, dentro de Scrub_read_endio(), revisamos los bvecs para encontrar el n\u00famero del sector (ya que bi_sector ya no es confiable si la biograf\u00eda se env\u00eda a capas inferiores). Y dado que la biograf\u00eda est\u00e1 vac\u00eda, dicha iteraci\u00f3n de bvecs no encontrar\u00eda ning\u00fan sector que coincida con el sector y devolver\u00eda sector_nr == stripe-&gt;nr_sectors, lo que activar\u00eda ASSERT(). [FIX] En lugar de llamar a btrfs_map_block() despu\u00e9s de asignar un nuevo bbio, llame primero a btrfs_map_block(). Dado que nuestro \u00fanico objetivo al llamar a btrfs_map_block() es solo actualizar stripe_len, realmente no hay necesidad de hacerlo despu\u00e9s de btrfs_alloc_bio(). Este nuevo tiempo evitar\u00eda por completo el problema de manejar bbio vac\u00edo y, de hecho, soluciona una posible ventana de ejecuci\u00f3npara el c\u00f3digo anterior, donde si el hilo de env\u00edo es el \u00fanico propietario de pendiente_io, la limpieza nunca terminar\u00eda (ya que no lo hicimos). disminuir el contador pendiente_io). Aunque a\u00fan es necesario abordar la causa ra\u00edz del error de b\u00fasqueda de RST."}], "metrics": {}, "references": [{"url": "https://git.kernel.org/stable/c/17d1fd302a53d7e456a7412da74be74a0cf63a72", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, {"url": "https://git.kernel.org/stable/c/2c49908634a2b97b1c3abe0589be2739ac5e7fd5", "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}], "techniques": [{"techniqueID": "TA0003", "comment": "CVE-2024-41067 - Path traversal and injection vulnerability allowing attacker to read sensitive information, must ensure secure coding practices and input validation"}, {"techniqueID": "TA0007", "comment": "CVE-2024-41067 - Error handling and debugging information reveals internal workings of system, need to ensure logs and debugging information are limited and restricted"}, {"techniqueID": "TA0010", "comment": "CVE-2024-41067 - Kernel mode privilege escalation, requires secure coding practices and configuration management"}, {"techniqueID": "TA0012", "comment": "CVE-2024-41067 - Command injection vulnerability allowing attacker to execute arbitrary commands, must ensure secure input validation and sanitization"}, {"techniqueID": "TA0024", "comment": "CVE-2024-41067 - Sensitive data exposure, needs to ensure sensitive data is properly encrypted and access controls are implemented"}], "technical_analysis": {"Introduction": "CVE-2024-41067 is a vulnerability in the Linux kernel affecting btrfs file system scrubbing, allowing attackers to read sensitive information and potentially escalate privileges.", "Impact and Scope": "The vulnerability has a CVSS score of 7.5 and an attack vector of Local. It allows attackers to read sensitive information and potentially escalate privileges.", "Related MITRE ATT&CK Techniques": "TA0003, TA0007, TA0010, TA0012, TA0024", "Technical Details": "The vulnerability occurs when the scrubbing process in btrfs file system fails to properly handle RST lookup errors, allowing attackers to read sensitive information.", "Detection": "Detection involves monitoring system logs for signs of malicious activity and implementing robust logging and auditing mechanisms.", "Mitigation": "Mitigation involves implementing secure coding practices, input validation, and sanitization, as well as limiting and restricting logs and debugging information.", "Conclusion": "CVE-2024-41067 is a critical vulnerability that requires immediate attention and mitigation to prevent exploitation and minimize potential impact."}, "executive_analysis": {"Overview": "CVE-2024-41067 is a critical vulnerability in the Linux kernel affecting btrfs file system scrubbing, requiring immediate attention and mitigation.", "Business Impact": "Exploitation of the vulnerability could lead to data breaches, data loss, and potential reputation damage.", "Technical Impact": "The vulnerability could allow attackers to read sensitive information and potentially escalate privileges, requiring immediate attention and mitigation.", "Mitigation Strategies": "Implement secure coding practices, input validation, and sanitization, as well as limiting and restricting logs and debugging information.", "Recommendations": "Executives should prioritize mitigation and implementation of robust logging and auditing mechanisms to minimize potential impact.", "Conclusions": "CVE-2024-41067 is a critical vulnerability requiring immediate attention and mitigation to prevent exploitation and minimize potential impact."}}